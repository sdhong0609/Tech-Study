# 의존
클래스 A가 클래스 혹은 인터페이스 B를 이용할 때 (예를 들면 객체 B를 생성하거나 객체 B의 메서드를 호출할 때),<br>
"A는 B에 의존한다" 혹은 "A가 의존성 B를 갖는다"고 표현합니다.<br>
이러한 상황에서 클래스 A를 의존적이라고 하고 클래스 B를 의존성이라고 합니다.<br>
클래스 간에 의존 관계가 있다는 것은 한 클래스가 바뀔 때, 다른 클래스가 영향을 받는다는 것을 의미합니다.

# 의존성 주입 (DI, Dependency Injection)
의존성 주입이란 클래스 간의 의존성을 클래스 외부에서 주입하는 것을 의미합니다.<br>
이렇게 의존성을 클래스 외부에서 주입하면 클래스 간의 결합도가 낮아져서 코드 변경에 영향을 덜 받게 되고, 다른 의존성으로 쉽게 교체 가능하여 애플리케이션을 유연한 구조로 만들고 테스트도 용이해집니다.<br>
예를 들면, DieselEngine 의존성을 사용하던 Car 클래스의 Engine을 쉽게 다른 Engine으로 교체하여 테스트할 수 있습니다.<br>
다만 개발자가 의존성 주입을 개별적으로 구현하는 것은 번거롭기 때문에, 안드로이드에는 의존성 주입을 더 용이하게 수행할 수 있는 Dagger, Hilt, Koin 등의 라이브러들이 개발되어 있습니다.

# 의존성 주입 방식
### 1. 생성자 주입
생성자 주입 방식은 객체를 생성하는 시점에 외부 객체를 생성자로 주입하는 방식입니다.
``` kotlin
abstract class Engine {

}

class DieselEngine: Engine() {
    val fuel = "diesel"
}

class Car(val engine: Engine) {

}

fun main() {
    val dieselEngine = DieselEngine()
    val car = Car(dieselEngine)
}
```
<br>

### 2. 메서드 주입
메서드 주입 방식은 객체의 생성이 끝난 뒤, 특정한 시점에서 메서드를 실행하여 외부 객체를 주입하는 방식입니다.
``` kotlin
abstract class Engine {
    
}

class DieselEngine: Engine() {
    val fuel = "diesel"
}

class Car {
    private lateinit var engine: Engine
    
    fun setEngine(engine: Engine) {
        this.engine = engine
    }
}

fun main() {
    val car = Car()
    val dieselEngine = DieselEngine()
    car.setEngine(dieselEngine)
}
```
<br>

### 3. 인터페이스를 통한 주입
인터페이스 주입 방식은 메서드 주입 방식과 유사한데, 다만 인터페이스를 통해 의존성을 주입한다는 차이점이 있습니다.
``` kotlin
abstract class Engine {

}

interface EngineInjector {
    fun inject(engine: Engine)
}

class DieselEngine : Engine() {
    val fuel = "diesel"
}

class Car: EngineInjector {
    private lateinit var engine: Engine
    
    override fun inject(engine: Engine) {
        this.engine = engine
    }
}

fun main() {
    val car = Car()
    val dieselEngine = DieselEngine()
    car.inject(dieselEngine)
}
```
